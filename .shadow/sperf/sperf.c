#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

// Feel free to change the data structures generated by AI.

#define MAX_SYSCALLS 1024
#define TOP_N 5
#define MAX_LINE_LEN 4096

typedef struct {
    char name[64];
    double time;
    int count;
} syscall_stat;

typedef struct {
    syscall_stat stats[MAX_SYSCALLS];
    int count;
    double total_time;
} syscall_stats;

int parse_strace_line(char *line, char *syscall_name, double *time) {
    // Parse strace line format: syscall_name(...) = result <time>
    // Example: "openat(AT_FDCWD, \"/etc/ld.so.cache\", O_RDONLY|O_CLOEXEC) = 3 <0.000123>"
    
    char *time_start = strrchr(line, '<');
    char *time_end = strrchr(line, '>');
    
    if (!time_start || !time_end || time_start >= time_end) {
        return 0; // No timing information found
    }
    
    // Extract time
    *time_start = '\0';
    *time_end = '\0';
    *time = atof(time_start + 1);
    
    // Extract syscall name
    char *paren = strchr(line, '(');
    if (!paren) {
        return 0;
    }
    
    *paren = '\0';
    
    // Skip leading whitespace and copy syscall name
    char *name_start = line;
    while (*name_start == ' ' || *name_start == '\t') {
        name_start++;
    }
    
    strncpy(syscall_name, name_start, 63);
    syscall_name[63] = '\0';
    
    return 1;
}

void add_syscall(syscall_stats *stats, const char *name, double time) {
    // Find existing syscall or create new entry
    for (int i = 0; i < stats->count; i++) {
        if (strcmp(stats->stats[i].name, name) == 0) {
            stats->stats[i].time += time;
            stats->stats[i].count++;
            stats->total_time += time;
            return;
        }
    }
    
    // Add new syscall if space available
    if (stats->count < MAX_SYSCALLS) {
        strncpy(stats->stats[stats->count].name, name, 63);
        stats->stats[stats->count].name[63] = '\0';
        stats->stats[stats->count].time = time;
        stats->stats[stats->count].count = 1;
        stats->count++;
        stats->total_time += time;
    }
}

int compare_syscalls(const void *a, const void *b) {
    const syscall_stat *stat_a = (const syscall_stat *)a;
    const syscall_stat *stat_b = (const syscall_stat *)b;
    
    if (stat_b->time > stat_a->time) return 1;
    if (stat_b->time < stat_a->time) return -1;
    return 0;
}

void print_top_syscalls(syscall_stats *stats, int n) {
    if (stats->count == 0) {
        printf("No syscalls recorded.\n");
        return;
    }
    
    // Sort syscalls by time
    qsort(stats->stats, stats->count, sizeof(syscall_stat), compare_syscalls);
    
    int show_count = (n < stats->count) ? n : stats->count;
    
    for (int i = 0; i < show_count; i++) {
        double percentage = (stats->stats[i].time / stats->total_time) * 100.0;
        printf("%s (%d): %.6f s (%.2f%%)\n", 
               stats->stats[i].name,
               stats->stats[i].count,
               stats->stats[i].time,
               percentage);
    }
}

char *find_command(const char *command) {
    // If command starts with '/', it's an absolute path
    if (command[0] == '/') {
        if (access(command, X_OK) == 0) {
            return strdup(command);
        } else {
            return NULL;
        }
    }
    
    // Search in PATH
    char *path_env = getenv("PATH");
    if (!path_env) {
        return NULL;
    }
    
    char *path_copy = strdup(path_env);
    char *dir = strtok(path_copy, ":");
    
    while (dir) {
        char full_path[1024];
        snprintf(full_path, sizeof(full_path), "%s/%s", dir, command);
        
        if (access(full_path, X_OK) == 0) {
            free(path_copy);
            return strdup(full_path);
        }
        
        dir = strtok(NULL, ":");
    }
    
    free(path_copy);
    return NULL;
}

int main(int argc, char *argv[]) {
    if (argc < 2) {
        fprintf(stderr, "Usage: %s COMMAND [ARG...]\n", argv[0]);
        fprintf(stderr, "Profile system calls of COMMAND execution\n");
        return 1;
    }
    
    // Find the command to execute
    char *command_path = find_command(argv[1]);
    if (!command_path) {
        fprintf(stderr, "sperf: command not found: %s\n", argv[1]);
        return 1;
    }
    
    // Create pipe for strace output
    int pipefd[2];
    if (pipe(pipefd) == -1) {
        perror("pipe");
        free(command_path);
        return 1;
    }
    
    pid_t pid = fork();
    if (pid == -1) {
        perror("fork");
        free(command_path);
        return 1;
    }
    
    if (pid == 0) {
        // Child process: run strace
        close(pipefd[0]); // Close read end
        
        // Redirect stderr to pipe
        dup2(pipefd[1], STDERR_FILENO);
        close(pipefd[1]);
        
        // Prepare arguments for strace
        char **strace_args = malloc((argc + 3) * sizeof(char*));
        strace_args[0] = "strace";
        strace_args[1] = "-T"; // Show time spent in each syscall
        strace_args[2] = command_path;
        
        // Copy remaining arguments
        for (int i = 2; i < argc; i++) {
            strace_args[i + 1] = argv[i];
        }
        strace_args[argc + 1] = NULL;
        
        execvp("strace", strace_args);
        perror("execvp strace");
        exit(1);
    } else {
        // Parent process: read strace output
        close(pipefd[1]); // Close write end
        
        FILE *strace_output = fdopen(pipefd[0], "r");
        if (!strace_output) {
            perror("fdopen");
            free(command_path);
            return 1;
        }
        
        syscall_stats stats = {0};
        char line[MAX_LINE_LEN];
        char syscall_name[64];
        double time;
        
        // Parse strace output
        while (fgets(line, sizeof(line), strace_output)) {
            if (parse_strace_line(line, syscall_name, &time)) {
                add_syscall(&stats, syscall_name, time);
            }
        }
        
        fclose(strace_output);
        
        // Wait for child process
        int status;
        waitpid(pid, &status, 0);
        
        // Print results
        printf("\nTop %d system calls by time:\n", TOP_N);
        print_top_syscalls(&stats, TOP_N);
        
        if (stats.total_time > 0) {
            printf("\nTotal time: %.6f s\n", stats.total_time);
        }
        
        free(command_path);
        return WEXITSTATUS(status);
    }
}
